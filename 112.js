// 어떤 스키장에서 리프트에 손님을 탑승시킬 때, 탑승장에 도착한 시간 뿐만 아니라, 손님의 티켓 등급도 고려하여 탑승 순서가 정해집니다. 이에 따른 탑승 순서를 다음과 같이 정합니다.

// 리프트는 일정한 시간 간격으로 한 대씩 탑승장으로 들어옵니다.
// 탑승장에 들어오는 순서대로 리프트에 번호를 부여합니다. 첫 번째 리프트부터 0번 리프트입니다.
// 라프트 한 대에는 한 명의 승객만 탑승합니다.
// 리프트 한 대가 출발하고, 다음 리프트가 도착하기 전까지 탑승장에 도착한 승객은 모두 같은 시각에 도착한 것으로 간주합니다.
// 손님들의 리프트 탑승장 도착 시각은 리프트 번호로 주어집니다.
// 즉, 손님이 리프트 탑승장에 도착한 후 바로 다음으로 탑승장에 들어오는 리프트 번호가 해당 손님이 탑승장에 도착한 시각입니다.
// 기존 탑승장에 대기중인 승객과 현재 도착한 승객 중에서 우선 순위가 가장 높은 탑승자를 선정합니다.
// 티켓 등급이 높을 수록 우선순위가 높으며, 등급이 가장 높은 손님이 여러 명일 경우는 먼저 도착한 순서대로 리프트에 탑승합니다.
// 도착한 시각(리프트 번호)과 등급이 같을 경우에는 아이디 값이 작은 손님이 먼저 탑승합니다.
// 각 손님의 도착 시각(리프트 번호)을 저장한 배열 t와 그 손님의 등급을 저장한 배열 r이 주어질 때, 탑승하는 손님의 순서를 return 하도록 solution 함수를 완성해 주세요.

function solution(t, r) {
  let answer = [];

  let guests = t.map((v, i) => [i, v, r[i]]);
  let wait = [];
  let lift = 0;

  do {
    const arrGuests = guests.filter((v) => v[1] === lift);
    wait = [...wait, ...arrGuests];
    if (wait.length > 0) {
      const choice = wait.sort((a, b) => a[2] - b[2]).shift();
      answer.push(choice);
      wait = wait.map((v) => [v[0], v[1] + 1, v[2]]);
    }
    lift++;
  } while (wait.length > 0 || answer.length !== guests.length);

  return answer.map((v) => v[0]);
}

console.log(solution([0, 1, 3, 0], [0, 1, 2, 3]));
console.log(solution([7, 6, 8, 1], [0, 1, 2, 3]));
