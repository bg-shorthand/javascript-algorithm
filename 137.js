// r x c 크기의 지도가 주어졌습니다. 지도에는 땅과 물의 정보가 표시되어 있습니다. 1 x 1 크기의 각 칸에는 1 또는 0으로 표시되어 있고, 1은 땅에 해당하는 공간, 0은 물에 해당하는 공간입니다. 이때, 땅이 상하좌우로 인접해 있으면 인접한 땅들을 하나의 섬이라고 합니다.

// 예를 들어, 4 x 5 크기의 지도가

// 섬1_t9aphz.png

// 로 주어졌을 때,

// 섬2_j3tjuh.png

// 섬이 2개가 있다고 판단합니다.

// 이와 같은 지도가 주어졌을 때, 우리는 각 섬이 물 또는 지도의 경계와 맞닿아 있는 부분의 길이를 구하고, 그중 가장 긴 길이를 구하려 합니다. 각 칸 모서리의 길이는 1을 나타냅니다. 즉, 위 지도에서 섬 A가 물 또는 지도의 경계와 맞닿아 있는 부분의 길이는 16이 되고, 섬 B의 경우는 8이 되어, 가장 긴 길이는 섬 A의 길이인 16이 됩니다.

// 지도가 매개변수 maps로 주어졌을 때, 각 섬이 물 또는 지도의 경계와 맞닿아 있는 부분의 길이 중 가장 긴 길이를 구하여 return 하는 solution 함수를 완성해 주세요.

// 제한사항
// 지도 maps는 2차원 배열로 주어지며, 0과 1 이외에 다른 숫자는 주어지지 않습니다.
// maps의 가로, 세로 길이는 50 이하인 자연수입니다.
// maps에 섬이 없는 경우 0을 return 하면 됩니다.
// 입출력 예
// maps    answer
// [[0,0,1,0,0],[0,1,1,0,1],[0,0,1,0,1],[1,1,1,0,1]]    16
// [[1,0,1,1],[0,0,1,1],[1,1,0,1],[1,1,0,0]]    10
// 입출력 예 설명
// 입출력 예 #1
// 문제의 예시와 같습니다.

// 입출력 예 #2

// 섬3_fndgxh.png

// 지도에 주어진 섬의 개수는 3개입니다.

// 섬 A의 길이 : 4
// 섬 B의 길이 : 10
// 섬 C의 길이 : 8
// 따라서 가장 긴 섬의 길이는 섬 B의 10이 됩니다.

function solution(maps) {
  answer = 0;
  let start = [];

  for (let i = 0; i < maps.length; i++) {
    for (let j = 0; j < maps[0].length; j++) {
      if (maps[i][j] === 1) start = [i, j];
      break;
    }
  }

  return answer;
}

console.log(
  solution([
    [0, 0, 1, 0, 0],
    [0, 1, 1, 0, 1],
    [0, 0, 1, 0, 1],
    [1, 1, 1, 0, 1],
  ])
);
